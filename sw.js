/** @typedef {import('./types').MapOptions} MapOptions */
/** @typedef {import('./types').MsgMapReady} MsgMapReady */
/** @typedef {import('./types').MsgReqMap} MsgReqMap */

const MSG_REQ_MAP = "request-map";
const MSG_MAP_READY = "map-ready";
const CACHE_NAME = "map-images";
const DEFAULT_STYLE = "mapbox://styles/mapbox/light-v9";
const basePathRe = /^\/static-maps/;
// Generated by `./lib/generate-regexp.js'
const pathRegExp = /^(?:\/(-?\d+(?:\.\d+)?))(?:,(-?\d+(?:\.\d+)?))(?:,(\d+(?:\.\d+)?))(?:,(-?\d+(?:\.\d+)?))?(?:,(-?\d+(?:\.\d+)?))?(?:\/(\d+))(?:x(\d+))(?:@(\d+)x)?[\/#\?]?$/i;

// @ts-ignore
// This is to work around TS not correctly typing self for Service Workers
init(self);

/** @param {ServiceWorkerGlobalScope} self */
async function init(self) {
  let id = 0;
  /** @type {Map<number, () => void>} */
  const pendingRequests = new Map();
  const cache = await self.caches.open(CACHE_NAME);

  self.addEventListener("install", function (event) {
    // The promise that skipWaiting() returns can be safely ignored.
    self.skipWaiting();
  });

  self.addEventListener("activate", (event) => {
    event.waitUntil(self.clients.claim());
  });

  self.addEventListener("message", ({ data: message }) => {
    if (!message || message.type !== MSG_MAP_READY) return;
    const { requestId } = /** @type {MsgMapReady} */ (message);
    // Static map should be ready in the cache by now
    const resolve = pendingRequests.get(requestId);
    pendingRequests.delete(requestId);
    if (resolve) resolve();
  });

  self.addEventListener("fetch", (event) => {
    const url = new URL(event.request.url);
    if (location.origin !== url.origin || !basePathRe.test(url.pathname))
      return;
    const path = url.pathname.replace(basePathRe, "");
    try {
      var mapOptions = parseMapOptions(path, url.searchParams);
    } catch (e) {
      return event.respondWith(
        new Response(null, { status: 400, statusText: e.message })
      );
    }
    const cacheKey = path + "?" + url.searchParams.toString();
    event.respondWith(mapResponse({ mapOptions, cacheKey }));
  });

  const responseInitOk = {
    status: 200,
    headers: {
      "Content-Type": "image/png",
    },
  };

  /**
   * @param {{mapOptions: MapOptions, cacheKey: string}} options
   * @returns {Promise<Response>}
   */
  async function mapResponse({ mapOptions, cacheKey }) {
    const cachedResponse = await cache.match(cacheKey);

    if (cachedResponse) {
      return new Response(cachedResponse.body, responseInitOk);
    }

    // Send a request to the first attached client for the map to be rendered
    const client = (await self.clients.matchAll({ type: "window" }))[0];
    const requestId = id++;
    /** @type {MsgReqMap} */
    const message = {
      requestId,
      cacheKey,
      mapOptions,
      type: MSG_REQ_MAP,
    };
    client.postMessage(message);

    return new Promise((resolve) => {
      pendingRequests.set(requestId, async () => {
        const cachedResponse = await cache.match(cacheKey);

        if (cachedResponse) {
          resolve(new Response(cachedResponse.body, responseInitOk));
        } else {
          resolve(new Response(null, { status: 404 }));
        }
      });
    });
  }
}

/**
 * Parse the pathname and search params from the request URL and return a map
 * configuration object
 * @param {string} pathname
 * @param {URLSearchParams} searchParams
 * @returns {MapOptions}
 */
function parseMapOptions(pathname, searchParams) {
  const match = pathRegExp.exec(pathname);
  if (!match) throw new Error("Invalid Request");

  const [
    ,
    lon,
    lat,
    zoom,
    bearing, // optional
    pitch, // optional
    width,
    height,
    pixelRatio, // optional
  ] = match.map(Number);
  const { isNaN } = Number;

  if (lon < -180 || lon > 180) {
    throw new Error("Longitude must be between -180 and 180");
  }
  if (lat < -90 || lat > 90) {
    throw new Error("Latitude must be between -90 and 90");
  }
  if (width > 2000 || height > 2000) {
    throw new Error("Max width and height is 2000");
  }

  return {
    center: [lon, lat],
    zoom,
    bearing: isNaN(bearing) ? 0 : bearing,
    pitch: isNaN(pitch) ? 0 : pitch,
    pixelRatio: pixelRatio !== undefined && !isNaN(pixelRatio) ? pixelRatio : 1,
    style: searchParams.get("style") || DEFAULT_STYLE,
    accessToken: searchParams.get("accessToken") || undefined,
    width,
    height,
  };
}
